{
  "language": "Solidity",
  "sources": {
    "contracts/MedicalContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MedicalContract {\n    address public owner;\n    string public contractTitle;\n    \n    struct Patient {\n        string name;\n        string cpf;\n        uint256 birthDate;\n        uint256 priority;\n        address doctorAddress;\n         address patientWalletAddress;\n        string bloodType;\n        uint256 recipientAge;\n        uint256 organSize;\n        uint256 urgency; // Fator de urgÃªncia\n        uint256 curability; // Fator de curabilidade\n        uint256 qConstant; // Fator Q Constant\n        uint256 queueEntryDate; // Data que foi adicionado na fila\n    }\n    \n    struct Record {\n        address patientAddress;\n        uint256 oldValue;\n        uint256 newValue;\n        string field;\n        address doctorAddress;\n        uint256 date;\n    }\n    \n    struct Doctor {\n        string crm;\n        address doctorAddress;\n    }\n    \n    mapping(address => Record[]) public records;\n    mapping(address => Doctor) public doctors;\n    mapping(address => Patient[]) public patientsByDoctor;\n    // mapping(address => Patient[]) public patientsByAddress;\n    Patient[] public allPatients;\n    \n    constructor(string memory _contractTitle) {\n        owner = msg.sender;\n        contractTitle = _contractTitle;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only contract owner can call this function\");\n        _;\n    }\n    \n    modifier onlyDoctor() {\n        require(doctors[msg.sender].doctorAddress != address(0), \"Only registered doctor can call this function\");\n        _;\n    }\n    \n    function addDoctor(address _doctorAddress, string memory _crm) public onlyOwner {\n        require(doctors[_doctorAddress].doctorAddress == address(0), \"Doctor already registered\");\n        \n        doctors[_doctorAddress] = Doctor(_crm, _doctorAddress);\n    }\n    \n    function addPatient(\n        string memory _name,\n        string memory _cpf,\n        uint256 _birthDate,\n        uint256 _priority,\n        string memory _bloodType,\n        uint256 _recipientAge,\n        address _patientWalletAddress,\n        uint256 _organSize,\n        uint256 _urgency,\n        uint256 _curability,\n        uint256 _qConstant\n    ) public onlyDoctor {\n        patientsByDoctor[msg.sender].push(Patient({\n            name: _name,\n            cpf: _cpf,\n            birthDate: _birthDate,\n            priority: _priority,\n            doctorAddress: msg.sender,\n            patientWalletAddress: _patientWalletAddress,\n            bloodType: _bloodType,\n            recipientAge: _recipientAge,\n            organSize: _organSize,\n            urgency: _urgency,\n            curability: _curability,\n            qConstant: _qConstant,\n            queueEntryDate: block.timestamp\n        }));\n        \n        allPatients.push(Patient({\n            name: _name,\n            cpf: _cpf,\n            birthDate: _birthDate,\n            priority: _priority,\n            doctorAddress: msg.sender,\n            patientWalletAddress: _patientWalletAddress,\n            bloodType: _bloodType,\n            recipientAge: _recipientAge,\n            organSize: _organSize,\n            urgency: _urgency,\n            curability: _curability,\n            qConstant: _qConstant,\n            queueEntryDate: block.timestamp\n        }));\n\n        // patientsByAddress[msg.sender].push(Patient({\n        //     name: _name,\n        //     cpf: _cpf,\n        //     birthDate: _birthDate,\n        //     priority: _priority,\n        //     doctorAddress: msg.sender,\n        //     patientWalletAddress: _patientWalletAddress,\n        //     bloodType: _bloodType,\n        //     recipientAge: _recipientAge,\n        //     organSize: _organSize,\n        //     urgency: _urgency,\n        //     curability: _curability,\n        //     qConstant: _qConstant,\n        //     queueEntryDate: block.timestamp\n        // }));\n    }\n    \n    function getDoctorCRM(address _doctorAddress) public view returns (string memory) {\n        require(doctors[_doctorAddress].doctorAddress != address(0), \"Doctor address is not registered\");\n        \n        return doctors[_doctorAddress].crm;\n    }\n    \n    function getAllPatientsByDoctor(address _doctorAddress) public onlyDoctor() view returns (Patient[] memory) {\n        return patientsByDoctor[_doctorAddress];\n    }\n\n    // function getMyData() public view returns (Patient[] memory) {\n    //     return patientsByAddress[msg.sender];\n    // }\n    \n    function getAllPatients() public view returns (Patient[] memory) {\n        // if sender is a doctor, return all patients with all data\n        if (doctors[msg.sender].doctorAddress != address(0)) {\n            return allPatients;\n        }\n\n        // if sender is not a doctor, return all expected name and cpf\n\n        Patient[] memory patients = new Patient[](allPatients.length);\n\n        for (uint256 i = 0; i < allPatients.length; i++) {\n            patients[i] = Patient({\n                name: \"\",\n                cpf: \"\",\n                birthDate: allPatients[i].birthDate,\n                priority: allPatients[i].priority,\n                doctorAddress: allPatients[i].doctorAddress,\n                patientWalletAddress: allPatients[i].patientWalletAddress,\n                bloodType: allPatients[i].bloodType,\n                recipientAge: allPatients[i].recipientAge,\n                organSize: allPatients[i].organSize,\n                urgency: allPatients[i].urgency,\n                curability: allPatients[i].curability,\n                qConstant: allPatients[i].qConstant,\n                queueEntryDate: allPatients[i].queueEntryDate\n            });\n        }\n        return patients;\n    }\n    \n    function getTitle() public view returns (string memory) {\n        return contractTitle;\n    }\n    \n    function elevatePriority(address _patientAddress, uint256 _newPriority) public onlyDoctor {\n        Patient[] storage patients = patientsByDoctor[msg.sender];\n        \n        for (uint256 i = 0; i < patients.length; i++) {\n            if (patients[i].patientWalletAddress == _patientAddress) {\n                require(_newPriority > patients[i].priority, \"New priority must be higher than current priority\");\n\n                records[_patientAddress].push(Record({\n                    patientAddress: _patientAddress,\n                    oldValue: patients[i].priority,\n                    newValue: _newPriority,\n                    field: \"priority\",\n                    doctorAddress: msg.sender,\n                    date: block.timestamp\n                }));\n                \n                patients[i].priority = _newPriority;\n                allPatients[i].priority = _newPriority;\n                // patientsByAddress[_patientAddress].priority = _newPriority;\n                \n                break;\n            }\n        }\n    }\n\n    function getPatientRecords(address _patientAddress) public view returns (Record[] memory) {\n        return records[_patientAddress];\n    }\n    \n    function getPatientByAddress(address _patientAddress) public view returns (string memory, string memory, uint256, uint256, address, address, string memory, uint256, uint256, uint256, uint256, uint256, Record[] memory ) {\n\n\n\n        for (uint256 i = 0; i < allPatients.length; i++) {\n            if (allPatients[i].patientWalletAddress == _patientAddress) {\n                if (msg.sender == allPatients[i].doctorAddress) {\n                    return (\n                        allPatients[i].name,\n                        allPatients[i].cpf,\n                        allPatients[i].birthDate,\n                        allPatients[i].priority,\n                        allPatients[i].doctorAddress,\n                        allPatients[i].patientWalletAddress,\n                        allPatients[i].bloodType,\n                        allPatients[i].recipientAge,\n                        allPatients[i].organSize,\n                        allPatients[i].urgency,\n                        allPatients[i].curability,\n                        allPatients[i].qConstant,\n                        records[allPatients[i].patientWalletAddress].length > 0 ? records[allPatients[i].patientWalletAddress] : new Record[](0)\n                    );\n                }\n\n                return (\n                    \"\",\n                    \"\",\n                    allPatients[i].birthDate,\n                    allPatients[i].priority,\n                    allPatients[i].doctorAddress,\n                    allPatients[i].patientWalletAddress,\n                    allPatients[i].bloodType,\n                    allPatients[i].recipientAge,\n                    allPatients[i].urgency,\n                    allPatients[i].curability,\n                    allPatients[i].qConstant,\n                    allPatients[i].queueEntryDate,\n                    records[allPatients[i].patientWalletAddress].length > 0 ? records[allPatients[i].patientWalletAddress] : new Record[](0)\n                );\n            }\n        }\n        \n        revert(\"Patient not found\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}